(load "common.scm")

;;; only included functions that needed to change
(define (make-ordered-deck)
  (define (make-suit s)
    (every (lambda (rank) (word rank s)) '(A 2 3 4 5 6 7 8 9 10 J Q K)) )
  (se (make-suit 'H) (make-suit 'S) (make-suit 'D) (make-suit 'C) '(JKR JKR)) )

(define (make-deck)
  (define (shuffle deck size)
    (define (move-card in out which)
      (if (= which 0)
	  (se (first in) (shuffle (se (bf in) out) (- size 1)))
	  (move-card (bf in) (se (first in) out) (- which 1)) ))
    (if (= size 0)
	deck
    	(move-card deck '() (random size)) ))
  (shuffle (make-ordered-deck) 54) )

(define (first-part card) (bl card))

(define (add-ace total num max)
  (define (iter num-11 num-1)
    (let ((new-total (+ total (* 11 num-11) (* 1 num-1))))
      (if (or (< new-total max) (<= num-11 0))
        new-total
        (iter (- num-11 1) (+ num-1 1)))))
  (iter num 0))

(define (add-jkr total num)
  (display total)
  (newline)
  (display num)
  (newline)
  (let ((rem (- 21 total))
        (max (* 11 num))
        (min (* 1 num)))
       (cond ((< rem min) (+ total min))
             ((and (>= rem min) (<= rem max)) 21)
             ((> rem max) (+ total max)))))

(define (card-joker? value)
  (or (equal? value 'JK) (equal? value 'jk)))

(define (best-total cards)
  (define (iter left total num-a num-jkr)
    (if (empty? left)
        (add-jkr (add-ace total num-a (* num-jkr 1)) num-jkr)
        (let ((point (first-part (first left))))
          (cond ((card-ace? point) (iter (bf left) total (+ num-a 1) num-jkr))
                ((card-picture? point) 
                 (iter (bf left) (+ total 10) num-a num-jkr))
                ((card-joker? point) 
                 (iter (bf left) total num-a (+ num-jkr 1)))
                ((number? point) (iter (bf left)
                            (+ point total) num-a num-jkr))
                (else (error point "not a number or one of the letters J Q K A"))))))
  (trace iter)
  (iter cards 0 0 0))
